"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  BitburnerPlugin: () => BitburnerPlugin
});
module.exports = __toCommonJS(index_exports);

// src/lib/RemoteApiServer.ts
var import_http = __toESM(require("http"));

// src/lib/RemoteFileMirror.ts
var import_path = __toESM(require("path"));
var import_promises = __toESM(require("fs/promises"));
var import_fs = require("fs");
var import_chokidar = require("chokidar");

// src/lib/log.ts
var import_esbuild = require("esbuild");
function createLogBatch() {
  return {
    logs: [],
    log(...args) {
      this.logs.push(args);
      return this;
    },
    error(...messages) {
      this.logs.push(
        (0, import_esbuild.formatMessagesSync)(
          messages.map((text) => ({ text })),
          { kind: "error", color: true }
        ).map((message) => message.trimEnd())
      );
      return this;
    },
    warn(...messages) {
      this.logs.push(
        (0, import_esbuild.formatMessagesSync)(
          messages.map((text) => ({ text })),
          { kind: "warning", color: true }
        ).map((message) => message.trimEnd())
      );
      return this;
    },
    dispatch() {
      while (this.logs.length) {
        console.log(...this.logs.shift());
      }
    }
  };
}

// src/lib/RemoteFileMirror.ts
var RemoteFileMirror = class _RemoteFileMirror {
  constructor() {
    this.fileCache = {};
    this.syncing = false;
    if (!_RemoteFileMirror.remoteApi) {
      throw new Error("Assign remoteAPI before instantiating");
    }
  }
  static async create(targetPath, servers, options) {
    const mirror = new _RemoteFileMirror();
    mirror.servers = typeof servers == "string" ? await _RemoteFileMirror.remoteApi.getAllServers().then(
      ({ result }) => result.filter(
        (s) => s.hasAdminRights && (servers == "own" ? s.purchasedByPlayer : servers == "other" ? !s.purchasedByPlayer : true)
      ).map((s) => s.hostname)
    ).catch((e) => {
      console.error(e);
      createLogBatch().error(
        JSON.stringify(e),
        `
Failed to initilize file mirror (${targetPath})`
      ).dispatch();
      return [];
    }) : servers;
    mirror.targetPath = targetPath;
    mirror.options = options;
    console.log(`Creating mirror [${mirror.servers.join(", ")}] => ${targetPath}`);
    return mirror;
  }
  async initFileCache() {
    console.log(`Initialising file cache for [${this.servers.join(", ")}]`);
    const files = (await import_promises.default.readdir(this.targetPath, { recursive: true, withFileTypes: true })).filter((f) => f.isFile());
    for (const file of files) {
      const filePath = import_path.default.join(file.parentPath, file.name).replaceAll("\\", "/");
      const content = (await import_promises.default.readFile(filePath)).toString("utf8");
      const remoteUrl = filePath.replace(this.targetPath, "").replace(
        /\/?(.*?)\//,
        "$1://"
      );
      this.fileCache[remoteUrl] = content;
    }
  }
  writeToFilesCache(files) {
    for (const file in files) {
      this.fileCache[file] = files[file];
    }
  }
  compareFilesToCache(files) {
    const diff = {
      mod: {},
      rem: {}
    };
    for (const file in files) {
      if (files[file] != this.fileCache[file]) {
        diff.mod[file] = files[file];
      }
    }
    for (const file in this.fileCache) {
      if (files[file] == void 0) {
        diff.rem[file] = this.fileCache[file];
      }
    }
    return diff;
  }
  async compareCacheToRemote() {
    const files = await this.getAllServerFiles();
    if (!files) return;
    return this.compareFilesToCache(files);
  }
  async getAllServerFiles() {
    const files = {};
    for (const server of this.servers) {
      const serverFiles = await _RemoteFileMirror.remoteApi.getAllFiles(server).catch((e) => console.log(e));
      if (!serverFiles) return;
      if (!serverFiles) continue;
      for (const { filename, content } of serverFiles.result) {
        files[`${server}://${filename}`] = content;
      }
    }
    return files;
  }
  async pushAllFiles() {
    await Promise.all(
      Object.keys(this.options.mirror ?? {}).map(async (mirrorPath) => {
        const mirrorDir = await import_promises.default.readdir(mirrorPath, { withFileTypes: true });
        const servers = mirrorDir.filter((f) => f.isDirectory()).map((d) => d.name);
        await Promise.all(servers.map(async (server) => {
          const files = await import_promises.default.readdir(`${mirrorPath}/${server}`, {
            recursive: true,
            withFileTypes: true
          });
          await Promise.all(
            files.filter((f) => f.isFile()).map(async ({ name, parentPath: filePath }) => {
              const sanitizedPath = filePath.replaceAll("\\", "/").replace(new RegExp(`^(./)?${mirrorPath}/${server}`), "");
              await _RemoteFileMirror.remoteApi.pushFile({
                server,
                filename: `${sanitizedPath}/${name}`,
                content: (await import_promises.default.readFile(`${filePath}/${name}`)).toString("utf8")
              });
            })
          );
        }));
      })
    ).catch((e) => console.log(e));
  }
  async syncWithRemote() {
    if (this.syncing) return;
    this.syncing = true;
    const logger = createLogBatch();
    try {
      const files = await this.getAllServerFiles();
      if (!files) return;
      const { mod: filesToWrite, rem: filesToRemove } = this.compareFilesToCache(files);
      this.writeToFilesCache(files);
      const diff = { ...filesToWrite, ...filesToRemove };
      if (Object.keys(diff).length != 0) {
        logger.log(`Remote change detected, syncing files with [${Object.keys(diff).map((k) => k.split("://", 2)[0]).filter((el, i, arr) => i == arr.indexOf(el)).join(", ")}]`);
      }
      for (const file in filesToWrite) {
        const content = filesToWrite[file];
        const filePath = import_path.default.join(this.targetPath, file.replace(/:\/\//, "/"));
        if (!(0, import_fs.existsSync)(import_path.default.dirname(filePath))) {
          await import_promises.default.mkdir(import_path.default.dirname(filePath), { recursive: true });
        }
        await import_promises.default.writeFile(filePath, content);
        logger.log(`Wrote file ${file} to ${filePath}`);
      }
      logger.dispatch();
      for (const file in filesToRemove) {
        delete this.fileCache[file];
        const filePath = import_path.default.join(this.targetPath, file.replace(/:\/\//, "/"));
        if (!(0, import_fs.existsSync)(filePath)) {
          continue;
        }
        await import_promises.default.rm(filePath);
        logger.log(`Deleted file ${file}`);
      }
      if (Object.keys(filesToRemove).length > 0 || Object.keys(filesToWrite).length > 0) {
        logger.log();
      }
    } catch (e) {
      logger.error(e.error ?? JSON.stringify(e));
    } finally {
      logger.dispatch();
      this.syncing = false;
    }
  }
  watch() {
    if (this.remotePollTimeout) {
      return;
    }
    const pollRemote = () => {
      this.syncWithRemote();
      this.remotePollTimeout = setTimeout(pollRemote, 500);
    };
    pollRemote();
    this.fileWatcher = (0, import_chokidar.watch)(this.targetPath, {
      ignoreInitial: true,
      usePolling: this.options.usePolling,
      interval: this.options.pollingInterval
    });
    this.fileWatcher.on("all", async (e, filePath) => {
      if (this.syncing) return;
      const deleted = !(0, import_fs.existsSync)(filePath);
      if (!deleted && !(await import_promises.default.stat(filePath)).isFile()) {
        return;
      }
      const sanitizedFilePath = filePath.replaceAll("\\", "/");
      const remoteServer = sanitizedFilePath.replace(this.targetPath, "").replace(
        /\/?(.*?)\/.*/,
        "$1"
      );
      const remotePath = sanitizedFilePath.replace(this.targetPath, "").replace(
        `/${remoteServer}/`,
        ""
      );
      const file = await _RemoteFileMirror.remoteApi.getFile({
        filename: remotePath,
        server: remoteServer
      }).catch((_) => void 0);
      if (deleted && !file) return;
      if (!deleted && file?.result == (await import_promises.default.readFile(sanitizedFilePath)).toString("utf8")) return;
      const logger = createLogBatch();
      logger.log(`Local change detected, syncing files with [${remoteServer}]`);
      if (deleted) {
        await _RemoteFileMirror.remoteApi.deleteFile({
          filename: remotePath,
          server: remoteServer
        }).then(() => logger.log(`Deleted file ${remoteServer}://${remotePath}`)).catch(
          (e2) => logger.error(
            `${e2.error ?? JSON.stringify(e2)} (${remoteServer}://${remotePath})`
          )
        );
        delete this.fileCache[`${remoteServer}://${remotePath}`];
      } else {
        const content = (await import_promises.default.readFile(sanitizedFilePath)).toString("utf8");
        await _RemoteFileMirror.remoteApi.pushFile({
          filename: remotePath,
          server: remoteServer,
          content
        }).then(
          () => logger.log(
            `Wrote file ${sanitizedFilePath} to ${remoteServer}://${remotePath}`
          )
        ).catch((e2) => logger.error(e2.error ?? JSON.stringify(e2)));
        this.writeToFilesCache({ [`${remoteServer}://${remotePath}`]: content });
      }
      logger.log().dispatch();
    });
  }
  dispose() {
    if (this.remotePollTimeout) {
      clearTimeout(this.remotePollTimeout);
    }
    if (this.fileWatcher) {
      this.fileWatcher.close();
    }
  }
};

// src/lib/RemoteApiServer.ts
var import_promises2 = __toESM(require("fs/promises"));
var import_fs2 = require("fs");
var import_chokidar2 = require("chokidar");
var import_websocket = require("websocket");
function isUtf8(event) {
  return event.type === "utf8";
}
var RemoteApiServer = class extends import_websocket.server {
  #counter;
  #queue;
  constructor(options) {
    super({
      httpServer: import_http.default.createServer((request, response) => {
        response.writeHead(404);
        response.end();
      }),
      autoAcceptConnections: false,
      maxReceivedMessageSize: 149e5,
      maxReceivedFrameSize: 149e5
    });
    this.#queue = /* @__PURE__ */ new Map();
    this.#counter = 1;
    this.options = options;
    RemoteFileMirror.remoteApi = this;
    this.connected = new Promise((resolve) => {
      this.once("client-connected", () => {
        console.log("Client connected");
        resolve();
      });
    });
  }
  on(event, cb) {
    super.on(event, cb);
    return this;
  }
  createMessageId() {
    return ++this.#counter;
  }
  listen(port, callback) {
    if (!this.config) throw new Error("Websocket not initilized");
    const httpServer = this.config.httpServer[0];
    if (httpServer.listening) {
      console.log(
        "WARNING: RemoteAPI Server is already listening on port " + httpServer.address().port
      );
      return;
    }
    httpServer.listen(port, callback);
    this.on("request", async (request) => {
      if (this.connection && this.connection.connected) {
        request.reject(400, "Only one client can connect at a time");
        return;
      }
      this.connection = request.accept(null, request.origin);
      this.connection.on("message", (e) => {
        if (!isUtf8(e)) {
          throw new Error("Unexpected binary data message");
        }
        const response = JSON.parse(e.utf8Data);
        if (this.#queue.has(response.id)) {
          this.#queue.get(response.id)[+("error" in response)](response);
          this.#queue.delete(response.id);
        }
      });
      this.emit("client-connected");
    });
  }
  mirror(targetPath, servers) {
    return RemoteFileMirror.create(targetPath, servers, this.options);
  }
  distribute(targetPath, to) {
    const distributor = (0, import_chokidar2.watch)(targetPath, {
      ignoreInitial: true,
      usePolling: this.options.usePolling,
      interval: this.options.pollingInterval
    });
    distributor.on("all", async (e, filePath) => {
      if (e != "add" && e != "change" || !(await import_promises2.default.stat(filePath)).isFile()) return;
      const logger = createLogBatch();
      const santizedFilePath = filePath.replaceAll("\\", "/");
      const content = (await import_promises2.default.readFile(filePath)).toString("utf8");
      const servers = typeof to == "string" ? await RemoteFileMirror.remoteApi.getAllServers().then(
        ({ result }) => result.filter(
          (s) => s.hasAdminRights && (to == "own" ? s.purchasedByPlayer : to == "other" ? !s.purchasedByPlayer : true)
        ).map((s) => s.hostname)
      ).catch((e2) => {
        console.error(e2);
        createLogBatch().error(
          JSON.stringify(e2),
          `
Failed to get distribution servers (${targetPath})`
        ).dispatch();
        return [];
      }) : to;
      if (!servers) return;
      console.log(`Distributing file ${filePath} to [${servers.join(", ")}]`);
      await Promise.allSettled(servers.map(
        (server) => this.pushFile({
          filename: santizedFilePath.replace(targetPath, ""),
          //strip basepath
          server,
          content
        })
      )).catch((e2) => logger.warn(e2.error ?? JSON.stringify(e2)).dispatch());
    });
    return () => {
      distributor.close();
    };
  }
  write(obj) {
    return new Promise((resolve, reject) => {
      if (!this.connection || !this.connection.connected) {
        reject("No open connection");
        return;
      }
      const id = this.createMessageId();
      const message = JSON.stringify({
        jsonrpc: "2.0",
        id,
        ...obj
      });
      this.#queue.set(id, [resolve, reject]);
      this.connection.send(message);
      setTimeout(() => reject("message timed out"), 1e4);
    });
  }
  getDefinitionFile() {
    return this.write({
      method: "getDefinitionFile"
    });
  }
  pushFile({ filename, content, server }) {
    return this.write({
      method: "pushFile",
      params: {
        filename,
        content,
        server
      }
    });
  }
  getFile({ filename, server }) {
    return this.write({
      method: "getFile",
      params: {
        filename,
        server
      }
    });
  }
  getFileNames(server) {
    return this.write({
      method: "getFileNames",
      params: {
        server
      }
    });
  }
  getAllFiles(server) {
    return this.write({
      method: "getAllFiles",
      params: {
        server
      }
    });
  }
  deleteFile({ filename, server }) {
    return this.write({
      method: "deleteFile",
      params: {
        filename,
        server
      }
    });
  }
  calculateRAM({ filename, server }) {
    return this.write({
      method: "calculateRam",
      params: {
        filename,
        server
      }
    });
  }
  getAllServers() {
    return this.write({
      method: "getAllServers"
    });
  }
};
function setupRemoteApi(opts) {
  const remoteAPI = new RemoteApiServer(opts);
  remoteAPI.on("client-connected", async () => {
    if (!opts.types) return;
    const types = await remoteAPI.getDefinitionFile();
    await import_promises2.default.writeFile(opts.types, types.result);
  });
  remoteAPI.on("client-connected", async () => {
    if (!opts.distribute) return;
    for (const path3 in opts.distribute) {
      const distribute = opts.distribute[path3];
      const dispose = remoteAPI.distribute(
        path3.replaceAll("\\", "/"),
        distribute
      );
      remoteAPI.addListener("close", () => dispose());
    }
  });
  remoteAPI.on("client-connected", async () => {
    if (!opts.mirror) return;
    const mirrors = [];
    for (const path3 in opts.mirror) {
      if (!(0, import_fs2.existsSync)(path3)) {
        await import_promises2.default.mkdir(path3, { recursive: true });
      }
      const servers = opts.mirror[path3];
      const mirror = await remoteAPI.mirror(
        path3.replaceAll("\\", "/"),
        servers
      );
      remoteAPI.addListener("close", () => mirror.dispose());
      mirrors.push(mirror);
    }
    for (const mirror of mirrors) {
      await mirror.initFileCache();
    }
    for (const mirror of mirrors) {
      if (opts.pushOnConnect) {
        await mirror.pushAllFiles();
      } else {
        await mirror.syncWithRemote();
      }
    }
    for (const mirror of mirrors) {
      mirror.watch();
    }
  });
  return remoteAPI;
}

// src/index.ts
var import_promises6 = __toESM(require("fs/promises"));
var import_fs4 = require("fs");

// src/plugins/react.ts
function reactPlugin(pluginBuild) {
  pluginBuild.onResolve({ filter: /^react(-dom)?$/ }, (opts) => {
    return {
      namespace: "react",
      path: opts.path
    };
  });
  pluginBuild.onLoad(
    { filter: /^react(-dom)?$/, namespace: "react" },
    (opts) => {
      if (opts.path == "react") {
        return {
          contents: "module.exports = React"
        };
      } else if (opts.path == "react-dom") {
        return {
          contents: "module.exports = ReactDOM"
        };
      }
    }
  );
}

// src/plugins/rust.ts
var import_esbuild2 = require("esbuild");
var import_path3 = __toESM(require("path"));
var import_promises3 = __toESM(require("fs/promises"));

// src/lib/rust-compiler.ts
var import_path2 = __toESM(require("path"));
var import_fs3 = require("fs");
var import_child_process = require("child_process");
function findCargoDir(path3) {
  if (path3 == process.cwd()) throw new Error("could not find cargo.toml");
  if ((0, import_fs3.existsSync)(import_path2.default.resolve(path3, "Cargo.toml"))) return path3;
  return findCargoDir(import_path2.default.resolve(path3, ".."));
}
async function compileProject(path3, outDir) {
  const projectRoot = findCargoDir(import_path2.default.dirname(path3));
  const packageOut = import_path2.default.resolve(outDir, "../.cache", import_path2.default.basename(projectRoot));
  const child = (0, import_child_process.spawn)("wasm-pack", [
    "build",
    "--target",
    "web",
    "--out-dir",
    packageOut
  ], {
    cwd: projectRoot,
    stdio: "inherit"
  });
  await new Promise((r) => child.addListener("exit", () => r()));
  return packageOut;
}

// src/plugins/rust.ts
function rustPlugin(pluginBuild) {
  pluginBuild.onLoad({ filter: /.*?\.rs$/ }, async (opts) => {
    const wasmPackage = await compileProject(
      opts.path,
      import_path3.default.resolve(pluginBuild.initialOptions.outdir)
    );
    const packageJson = await import_promises3.default.readFile(
      import_path3.default.join(wasmPackage, "package.json"),
      { encoding: "utf-8" }
    ).then((p2) => JSON.parse(p2));
    const wasmFile = packageJson.files.find((f) => f.endsWith(".wasm"));
    const contents = await (0, import_esbuild2.transform)(
      `
        import wasm from "${wasmPackage}/${wasmFile}";
        import init, {main as wasmMain} from "${wasmPackage}";
        export const main = async (ns) => (await init(wasm), wasmMain(ns));
        `,
      { minify: true }
    ).then((c) => c.code);
    return {
      contents
    };
  });
  pluginBuild.onEnd(async (result) => {
    const wasmPackages = Object.entries(result.metafile?.outputs ?? {}).filter(([, { entryPoint }]) => entryPoint.endsWith(".rs")).map(([out, { entryPoint }]) => [import_path3.default.resolve(out), import_path3.default.resolve(entryPoint)]);
    for (const [originalOutFile, entrypoint] of wasmPackages) {
      const newOutFile = originalOutFile.replace(
        entrypoint.replace(
          import_path3.default.resolve(findCargoDir(entrypoint)),
          ""
        ).replace(/.rs$/, ".js"),
        ".js"
      );
      await import_promises3.default.copyFile(originalOutFile, newOutFile);
      await import_promises3.default.rm(import_path3.default.resolve(import_path3.default.dirname(originalOutFile), ".."), {
        recursive: true
      });
    }
  });
}

// src/plugins/debugging.ts
var import_promises4 = __toESM(require("fs/promises"));
async function fixSourceMappings(outdir) {
  const outputFiles = await import_promises4.default.readdir(outdir, {
    recursive: true,
    withFileTypes: true
  }).then((f) => f.filter((f2) => f2.isFile()));
  const relativeSourceMapToAbsolute = (content) => {
    if (!content) return content;
    if (!content.includes("//# sourceMappingURL=")) {
      return content;
    }
    const [pretext, sourcemapText] = content.split(
      "//# sourceMappingURL=data:application/json;base64,"
    );
    if (!sourcemapText) return content;
    const sourcemap = JSON.parse(
      Buffer.from(sourcemapText, "base64").toString()
    );
    sourcemap.sources = sourcemap.sources.map((source) => {
      return source.startsWith(".") ? source.replace(/(\.\.\/)*/, "./") : source;
    });
    const newText = `${pretext}
//# sourceMappingURL=data:application/json;base64,${Buffer.from(JSON.stringify(sourcemap)).toString("base64")}`;
    return newText;
  };
  await Promise.all(
    outputFiles.map(
      async (file) => import_promises4.default.writeFile(
        `${file.parentPath}/${file.name}`,
        relativeSourceMapToAbsolute(
          await import_promises4.default.readFile(`${file.parentPath}/${file.name}`, { encoding: "utf8" })
        )
      )
    )
  ).catch((_) => console.log(_));
}

// src/plugins/logging.ts
var import_esbuild3 = require("esbuild");
async function loggingPlugin(pluginBuild) {
  pluginBuild.onEnd(async (result) => {
    if (!result.errors.length && !result.warnings.length) return;
    if (["silent", "verbose", "debug"].includes(pluginBuild.initialOptions.logLevel)) {
      return;
    }
    const warnings = await (0, import_esbuild3.formatMessages)(result.warnings, {
      kind: "warning",
      color: true
    });
    const errors = await (0, import_esbuild3.formatMessages)(result.errors, {
      kind: "error",
      color: true
    });
    while (warnings.length && pluginBuild.initialOptions.logLevel != "error") {
      console.log(warnings.shift()?.trimEnd());
      console.log();
    }
    while (errors.length) {
      console.log(errors.shift()?.trimEnd());
      console.log();
    }
  });
}

// src/lib/upload.ts
var import_promises5 = __toESM(require("fs/promises"));
async function upload(outdir, remoteAPI) {
  const rawFiles = (await import_promises5.default.readdir(outdir, { recursive: true, withFileTypes: true })).filter((file) => file.isFile()).map((file) => ({
    name: file.name,
    path: file.parentPath.replaceAll("\\", "/").replace(/^.*?\//, "")
    // rebase path
  })).map((file) => ({
    server: file.path.split("/")[0],
    filename: `${file.path}/${file.name}`.replace(/^.*?\//, ""),
    path: `${outdir}/${file.path}/${file.name}`
  }));
  const logger = createLogBatch();
  const validServers = await rawFiles.reduce(async (prev, { server }) => {
    return prev.then(async (prev2) => {
      if (prev2[server]) return prev2;
      prev2[server] = await remoteAPI.getFileNames(server).then((_) => true).catch((_) => false);
      if (!prev2[server]) {
        logger.warn(
          `Invalid server '${server}': ignoring files to be pushed to '${server}'`
        );
      }
      return prev2;
    });
  }, Promise.resolve({}));
  const files = rawFiles.filter((f) => validServers[f.server]);
  const failed_files = [];
  await Promise.all(
    files.map(async ({ filename, server, path: path3 }) => remoteAPI.pushFile({
      filename,
      server,
      content: (await import_promises5.default.readFile(path3)).toString("utf8")
    }).catch(
      ({ error }) => {
        logger.error(`Can not push "${filename}" to "${server}": ${error}`);
        failed_files.push({ filename, server });
      }
    ))
  );
  logger.dispatch();
  return Promise.all(
    files.filter((file) => !failed_files.find(
      (failed_file) => file.filename == failed_file.filename && file.server == failed_file.server
    )).map(async ({ filename, server }) => ({
      filename,
      server,
      cost: await remoteAPI.calculateRAM({ filename, server }).then((response) => response.result).catch(() => 0)
    }))
  );
}

// src/index.ts
function parseExtensions(extensions = []) {
  return extensions.reduce(
    (prev, cur) => {
      for (const key in prev) {
        const extension = cur[key];
        if (extension) {
          prev[key].push(extension);
        }
      }
      return prev;
    },
    {
      setup: [],
      beforeConnect: [],
      afterConnect: [],
      beforeBuild: [],
      afterBuild: []
    }
  );
}
var BitburnerPlugin = (opts = {}) => ({
  name: "BitburnerPlugin",
  async setup(pluginBuild) {
    const { outdir, logLevel } = pluginBuild.initialOptions;
    if (!opts.port) {
      throw new Error("No port provided");
    }
    if (pluginBuild.initialOptions.write) {
      throw new Error("BitburnerPlugin doesn't support 'write' mode");
    }
    if (!outdir) {
      throw new Error("BitburnerPlugin requires the outdir option to be set");
    }
    if (!["verbose", "debug"].includes(logLevel)) {
      pluginBuild.initialOptions.logLevel = "silent";
    }
    if (typeof opts != "object") {
      throw new TypeError("Expected options to be an object");
    }
    if (opts.remoteDebugging) {
      pluginBuild.initialOptions.sourcemap ??= "inline";
      pluginBuild.initialOptions.sourcesContent ??= false;
      pluginBuild.initialOptions.sourceRoot ??= "/";
    }
    pluginBuild.initialOptions.metafile = true;
    pluginBuild.initialOptions.loader ??= {};
    pluginBuild.initialOptions.loader[".wasm"] = "binary";
    const extensions = parseExtensions(opts.extensions);
    await runExtensions(extensions.setup);
    const remoteAPI = setupRemoteApi(opts);
    ;
    pluginBuild.onDispose(() => {
      remoteAPI.shutDown();
    });
    await runExtensions(extensions.beforeConnect);
    remoteAPI.listen(opts.port, () => {
      console.log("\u2705 RemoteAPI Server listening on port " + opts.port);
    });
    remoteAPI.on("client-connected", async () => {
      await runExtensions(extensions.afterConnect, remoteAPI);
    });
    let queued = false;
    let startTime;
    pluginBuild.onStart(() => runExtensions(extensions.beforeBuild));
    pluginBuild.onStart(async () => {
      startTime = Date.now();
      if ((0, import_fs4.existsSync)(outdir)) {
        await import_promises6.default.rm(outdir, { recursive: true });
      }
    });
    reactPlugin(pluginBuild);
    rustPlugin(pluginBuild);
    loggingPlugin(pluginBuild);
    pluginBuild.onEnd(async (result) => {
      if (result.errors.length != 0) return;
      if (queued) return;
      const logger = createLogBatch();
      const endTime = Date.now();
      if (!remoteAPI.connection || !remoteAPI.connection.connected) {
        queued = true;
        console.log("Build successful, waiting for client to connect");
        await remoteAPI.connected;
      }
      if (opts.remoteDebugging) {
        await fixSourceMappings(pluginBuild.initialOptions.outdir);
      }
      await runExtensions(extensions.afterBuild, remoteAPI);
      const filesWithRAM = await upload(outdir, remoteAPI);
      const formatOutputFiles = (files) => {
        return files.map(
          (file) => `  \x1B[33m\u2022\x1B[0m ${file.server}://${file.filename} ${file.cost ? `\x1B[32mRAM: ${file.cost}GB\x1B[0m` : ""}`
        );
      };
      logger.dispatch();
      console.log();
      console.log(formatOutputFiles(filesWithRAM).join("\n"));
      console.log();
      console.log(
        `\u26A1 \x1B[32mDone in \x1B[33m${endTime - startTime}ms\x1B[0m`
      );
      console.log();
      queued = false;
    });
  }
});
async function runExtensions(extensions, ...args) {
  const logger = createLogBatch();
  for (const extension of extensions) {
    await Promise.resolve(extension(...args)).catch((e) => logger.error(e.error ?? JSON.stringify(e)));
  }
  logger.dispatch();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BitburnerPlugin
});
//!BAD this doesnt get the dir path of the path but just the name
